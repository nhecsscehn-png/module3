#include <iostream>

template<typename T>
class Point {
public:
    T x, y;

    // Constructeur
    Point(T x = T{}, T y = T{}) : x(x), y(y) {}

    // MÃ©thode membre modifiÃ©e : passage par const&
    void translate(const T& dx, const T& dy) {
        x += dx;
        y += dy;
        // Log optionnel ajoutÃ© dans cette branche (simule debug)
        // std::cerr << "Translated by (" << dx << ", " << dy << ")\n";
    }
};

// OpÃ©rateur + volontairement modifiÃ© pour soustraction (cas d'usage particulier)
template<typename T>
Point<T> operator+(const Point<T>& a, const Point<T>& b) {
    return Point<T>(a.x - b.x, a.y - b.y); // ğŸ” intentionnel : a - b
}

// OpÃ©rateur << avec format dÃ©taillÃ© (et saut de ligne final)
template<typename T>
std::ostream& operator<<(std::ostream& os, const Point<T>& p) {
    return os << "Point{x=" << p.x << ", y=" << p.y << "}\n";
}

// Exemple d'utilisation
int main() {
    Point<int> p1(2, 3), p2(4, 5);
    Point<int> p3 = p1 + p2;
    std::cout << p3 << std::endl;  // Affiche : Point{x=-2, y=-2}

    Point<double> q1(1.5, 2.5), q2(0.5, 1.0);
    q1.translate(1.0, 1.0);
    std::cout << q1 + q2 << std::endl;  // Affiche : Point{x=2, y=2.5}

    return 0;
}
