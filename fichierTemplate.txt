#include <iostream>
#include <cmath>

template<typename T>
class Point {
private:
    T _x, _y;

public:
    // Constructeur
    Point(T x = T{}, T y = T{}) : _x(x), _y(y) {}

    // Getters & Setters (API sécurisée)
    T x() const { return _x; }
    T y() const { return _y; }
    void setX(const T& val) { _x = val; }
    void setY(const T& val) { _y = val; }

    // Méthode membre ajoutée : distance à l'origine
    double distanceToOrigin() const {
        return std::sqrt(_x * _x + _y * _y);
    }

    // translate réécrit avec getters/setters (cohérent avec l'encapsulation)
    void translate(const T& dx, const T& dy) {
        setX(_x + dx);
        setY(_y + dy);
    }
};

// Opérateur + rétabli à l'addition standard (cohérence mathématique)
template<typename T>
Point<T> operator+(const Point<T>& a, const Point<T>& b) {
    return Point<T>(a.x() + b.x(), a.y() + b.y());
}

// Opérateur << adapté aux getters
template<typename T>
std::ostream& operator<<(std::ostream& os, const Point<T>& p) {
    return os << "(" << p.x() << ", " << p.y() << ")";
}

// Exemple d'utilisation étendu
int main() {
    Point<double> p(3.0, 4.0);
    std::cout << p << " → dist = " << p.distanceToOrigin() << std::endl;

    Point<int> p1(1, 2), p2(2, 3);
    Point<int> p3 = p1 + p2;
    p3.translate(1, 1);
    std::cout << p3 << std::endl;

    return 0;
}