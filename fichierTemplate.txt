#include <iostream>
#include <string>

template<typename T>
class Point {
public:
    T x, y;

    Point(T x = T{}, T y = T{}) : x(x), y(y) {}

    // Nouvelle méthode membre : operator+= (efficacité)
    Point& operator+=(const Point& other) {
        x += other.x;
        y += other.y;
        return *this;
    }

    void translate(const T& dx, const T& dy) {
        x += dx;
        y += dy;
    }
};

// Spécialisation partielle pour T = int → ajout de snapping
template<>
Point<int> operator+(const Point<int>& a, const Point<int>& b) {
    // Ex: ajoute un petit bruit aléatoire (simule correction matérielle)
    static int noise = 0;
    noise = (noise + 1) % 3 - 1; // -1, 0, +1
    return Point<int>(a.x + b.x + noise, a.y + b.y + noise);
}

// Version générique inchangée (fallback)
template<typename T>
Point<T> operator+(const Point<T>& a, const Point<T>& b) {
    return Point<T>(a.x + b.x, a.y + b.y);
}

// Opérateur << en format JSON (ex: API web)
template<typename T>
std::ostream& operator<<(std::ostream& os, const Point<T>& p) {
    return os << "{\"x\":" << p.x << ",\"y\":" << p.y << "}";
}

// Exemple d'utilisation
int main() {
    Point<int> p1(10, 20), p2(5, 5);
    Point<int> p3 = p1 + p2;
    p3 += Point<int>(1, 1);
    std::cout << p3 << std::endl;  // ex: {"x":16,"y":25} (±bruit)

    Point<double> q(1.1, 2.2);
    q += Point<double>(0.9, 0.8);
    std::cout << q << std::endl;   // {"x":2,"y":3}

    return 0;
}
