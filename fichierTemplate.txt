#include <iostream>
#include <string>
#include <cmath>

template<typename T>
class Point {
private:
    T _x, _y;

public:
    T x, y;

    Point(T x = T{}, T y = T{}) : x(x), y(y) {}

    // Nouvelle méthode membre : operator+= (efficacité)
    Point& operator+=(const Point& other) {
        x += other.x;
        y += other.y;
        return *this;
    }

    void translate(const T& dx, const T& dy) {
        setX(_x + dx);
        setY(_y + dy);
    }
};

// Opérateur + rétabli à l'addition standard (cohérence mathématique)
template<typename T>
Point<T> operator+(const Point<T>& a, const Point<T>& b) {
    return Point<T>(a.x() + b.x(), a.y() + b.y());
}

// Opérateur << adapté aux getters
template<typename T>
std::ostream& operator<<(std::ostream& os, const Point<T>& p) {
    return os << "Point{x=" << p.x << ", y=" << p.y << "}\n";
}

// Exemple d'utilisation étendu
int main() {
    Point<double> p(3.0, 4.0);
    std::cout << p << " → dist = " << p.distanceToOrigin() << std::endl;

    Point<int> p1(1, 2), p2(2, 3);
    Point<int> p3 = p1 + p2;
    p3 += Point<int>(1, 1);
    std::cout << p3 << std::endl;  // ex: {"x":16,"y":25} (±bruit)

    Point<double> q(1.1, 2.2);
    q += Point<double>(0.9, 0.8);
    std::cout << q << std::endl;   // {"x":2,"y":3}
    std::cout << p3 << std::endl;  // Affiche : Point{x=-2, y=-2}  // Affiche : (6, 8)

    Point<double> q1(1.5, 2.5), q2(0.5, 1.0);
    q1.translate(1.0, 1.0);
    std::cout << q1 + q2 << std::endl;  // Affiche : Point{x=2, y=2.5}  // Affiche : (3.5, 4.5)

    return 0;
}